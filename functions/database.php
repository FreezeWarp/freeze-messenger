<?php
/* FreezeMessenger Copyright Â© 2017 Joseph Todd Parsons

 * This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>. */

/**** BRIEF INTRODUCTION ****/
/* This file is the outline of FreezeMessenger's database class. The legwork will be performed by another class (usually databaseSQL), while this defines variables and includes documentation for the interface. */


/**** TODO ****/
/*
 * insert triggers (e.g. a watch() function)
 */


/**
 * Database operations that must be implemented by a driver, and other helper functionality.
 *
 * @author Joseph Todd Parsons <josephtparsons@gmail.com>
 */
abstract class database
{
    /**
     * @var int The number of queries this instance of the database has executed.
     */
    public $queryCounter = 0;

    /**
     * @var int The insert ID of the last query, if applicable. May or may not be reset after queries without insert IDs (e.g. SELECT) are run.
     */
    public $insertId = null;

    /**
     * @var array An array of textual error messages generated by the database.
     */
    public $errors = array();

    /**
     * @var bool Whether or not to print out database errors when we encounter them.
     */
    public $printErrors = false;

    /**
     * @var string A function to be invoked when an error is encountered. The error data will be passed to this function as a JSON-formatted array.
     */
    public $errorFormatFunction = '';

    /**
     * @var int The PHP error level to invoke when errors are encountered.
     */
    protected $errorLevel = E_USER_ERROR;

    /**
     * @var array An array of valid storage types. Commonly includes 'general' and 'memory'
     */
    public $storeTypes = ['general'];

    /**
     * @var string The currently active/selected database, if any.
     */
    protected $activeDatabase = null;

    /**
     * @var array Arbitrary connection information that may be set by drivers.
     */
    public $connectionInformation = array();

    /**
     * @var array An array holding a WHERE clause to be used by the next applicable query. Used to aid {@link database::where()}
     */
    protected $conditionArray = array();

    /**
     * @var array An array holding a ORDER BY clause to be used by the next applicable query. Used to aid {@link database::sortBy()}
     */
    protected $sortArray = array();

    /**
     * @var array An array holding a LIMIT clause to be used by the next applicable query. Used to aid {@link database::limit()}
     */
    protected $limitArray = array();

    /**
     * @var array An array of data instructing how to perform hard partitioning on a query if that information is not otherwise available. See {@link database::partitionAt()} for more.
     */
    protected $partitionAt = array();

    /**
     * @var bool Whether or not to queue new query operations. Turned on and off by {@link databased::autoQueue()}.
     */
    protected $autoQueue = false;

    /**
     * @var array An array of queued update queries.
     */
    protected $updateQueue = array();

    /**
     * @var array An array of queued delete queries.
     */
    protected $deleteQueue = array();

    /**
     * @var array An array of queued insert queries.
     */
    protected $insertQueue = array();

    /**
     * @var array Configuration data that modifies how data is stored on the way to the database, and on return.
     * Database drivers are encourage to support, but not required to if they can natively process all core PHP datatypes, including arrays.
     */
    public $encode = [];

    /**
     * @var array Configuration data that allows data to be manipulated (like above) and then copied to secondary columns.
     * Database drivers are required to support.
     */
    public $encodeCopy = [];

    /**
     * @var array Configuration data to allow individual rows to be partioned to seperate (but identical) tables for performance reasons
     * Database drivers are not required to support.
     */
    public $hardPartitions = [];

    /**
     * @var array Configuration data that tells the driver to store data aggregates in more performant locations.
     * Database drivers are required to support.
     */
    public $collectionTriggers = [];

    public $sqlPrefix;


    /*********************************************************
     ************************ START **************************
     ******************* General Functions *******************
     *********************************************************/

    /**
     * Connects to the database using {@link database::connect()}
     */
    public function __construct($host = false, $port = false, $user = false, $password = false, $database = false, $driver = false, $tablePrefix = '')
    {
        if ($host !== false) $this->connect($host, $port, $user, $password, $database, $driver, $tablePrefix);
    }


    /**
     * Does nothing.
     */
    public function __destruct()
    {

    }

    /**
     * @param $haystack
     * @param $needle
     * @return bool     True if $haystack starts with $needle, false otherwise.
     */
    public function startsWith($haystack, $needle)
    {
        return (strpos($haystack, $needle) === 0);
    }


    /**
     * @param $haystack
     * @param $needle
     * @return bool     True if $haystack ends with $needle, false otherwise.
     */
    public function endsWith($haystack, $needle)
    {
        return (substr($haystack, -strlen($needle)) === $needle);
    }


    /**
     * Connect to a database server.
     *
     * Connect to MySQL server using MySQLi driver:
     * ```php
     * $db = new database()
     * $dB->connect('localhost', 3306, 'root', 'r00tpassword', 'database1', 'mysqli');
     * ```
     *
     * Alternatively, the connection information can be specified in the __construct() call:
     * ```php
     * $db = new database('localhost', 3306, 'root', 'r00tpassword', 'database1', 'mysqli');
     * ```
     *
     * Implementor Notes:
     *  - Implementors who use a file (e.g. JSON) instead of a database are suggested to use "host", "user", and "password" as login details for a remote session, with "database" corresponding to the proper file. "user" and "password" could also be used to authenticate access to the file itself, but it is recommended that this be the same as the remote login information, if a remote login is used. Similarily, implementors who use a PHP object should follow the same remote guidelines if a remote session is possible, with the "database" corresponding with the unique object identifier.
     *  - Ideally, all alternative SQL implementations should use databaseSQL.php. If, however, you are creating an SQL implementation, please respect the procedure used there: $host as the server host, $port as the server port, $user as the authentication name, $password as the authentication password, $database as the database name, and $driver as a unique reference to your implementation. Again, user and password should be the same used for server authentication as for database authentication. If an implementation uses SQLite or a similar file-based cache, the file location should be that of the either $database or $host, as best determined by the implementor.
     *
     * @param string    $host       The host of the database server.
     * @param int       $port       The port the server is located on, if applicable. (Note: Some drivers, like MySQL, normally include the port in the host. For this abstraction, please seperate the host and the port, including them in $host and $port respectively.)
     * @param string    $user       The database user
     * @param string    $password   The password of the user.
     * @param string    $database   The database to connect to. (Note: This can be selected using selectDatabase(), but for most purposes it should be specified now.)
     * @param string    $driver     The driver that will power the abstraction. At present, only "mysql" and "mysqli" are supported.
     *
     * @return bool - True if a connection was successfully established, false otherwise.
     */
    abstract public function connect($host, $port, $user, $password, $database, $driver, $tablePrefix);


    /**
     * Closes a connection to a database server.
     *
     * @return void
     */
    abstract public function close();



    /*********************************************************
     ************************* END ***************************
     ******************* General Functions *******************
     *********************************************************/


    /*********************************************************
     ************************ START **************************
     ******************** Error Handling *********************
     *********************************************************/

    /**
     * Trigger an Error
     * When a database error is encountered, database implementations should call this function. It will both store the error in the $this->errors property and, potentially, log the error. $errorType should be specified to determine whether or not the error is critical (see below).
     *
     * In this example, an error, "Database is locked.", will be issued using the defined error level.
     * ```php
     * $this->triggerError('Database is locked.', 'function');
     * ```
     *
     * @param string    $errorMessage   The error message to issue.
     * @param mixed     $errorData      Additional information about the error.
     * @param string    $errorType      The type of error encountered, one of:
     *  - 'function' - A function returns false. For instance, selectDB() fails because a database could not be found.
     *  - 'syntax' - A function can not complete due to a syntax error. Some drivers may not trigger this kind of error.
     *  - 'validation' - A function can not complete because the data specified does not validate, for instance a value is not recognised or is of the wrong type.
     *  - 'validationFallback' - A function encountered a validation error, but will recover by making an assumption about the intended data.
     *  - 'connection' - A connection failed. For instance, connect() returns false or the MySQL server is down. The latter error may not always be detected.
     *  - 'logic' - A logic error in the function occured. (Honestly, you should probably throw an exception instead, but whatever.)
     * @param bool      $suppressErrors     Do not trigger an error. The error will still be logged, but it will not interupt the program flow.
     *
     * @return void
     */
    protected function triggerError($errorMessage, $errorData = '', $errorType = false, $suppressErrors = false)
    {
        if ($this->printErrors) { // Trigger error is not guaranteed to output the error message to the client. If this flag is set, we send the message before triggering the error. (At the same time, multiple messages may appear.)
            echo $errorMessage;
        }

        $this->newError($errorMessage . "\nAdditional Information:\n" . print_r($errorData, true));

        if ($errorType === 'validationFallback') {
            // TODO
            // validation errors are warnings
        }
        else {
            // If transaction mode is active, then any error will result in a rollback and the closure of the connection. Once transaction mode is ended, errors no longer result in a connection closure.
            if ($this->transaction) {
                $this->rollbackTransaction();
                $this->close();
            }


            if (!$suppressErrors) {
                if ($this->errorFormatFunction && function_exists($this->errorFormatFunction)) {
                    throw new $this->errorFormatFunction('dbError', json_encode(array(
                        "Message" => $errorMessage,
                        "Database Error" => $this->getLastError(),
                        "Error Data" => $errorData,
                        "Query Log" => $this->queryLog,
                        "Stack Trace" => debug_backtrace(false),
                    )));
                }
                else {
                    throw new Exception('A database error has occurred (' . $this->getLastError() . '). Additional Data: "' . $errorData . '"');
                }
            }
            else {
                throw new Exception('A database error has occured.');
            }
        }
    }


    /**
     * Defines what error level should be used for all database errors called by the class. Class exceptions will not be affected.
     *
     * This function's main purpose in suppressing errors at certain points in script execution, e.g.:
     * ```php
     * $db = new database('localhost', 3306, 'root', 'r00tpassword', 'database1', 'mysqli');
     * $db->setErrorLevel(E_NOTICE); // Suppress errors
     * #...
     * if (count($db->select(...)) > 5) {
     *   trigger_error('Too many results in query.', $db->errorLevel);
     * }
     * ```
     *
     * @param int   $errorLevel   The PHP error level to use for all errors called by the class.
     *
     * @return int  The new error level.
     */
    public function setErrorLevel($errorLevel)
    {
        return $this->errorLevel = $errorLevel;
    }


    /**
     * Get the Current Error Level
     *
     * This function should be used to retrieve the current error level. It could be useful, for instance, in showing other errors outside of the database class, e.g:
     * ```php
     * $db = new database('localhost', 3306, 'root', 'r00tpassword', 'database1', 'mysqli');
     * ...
     * if (count($db->select(...)) > 5) {
     *   trigger_error('Too many results in query.', $db->errorLevel);
     * }
     * ```
     *
     * @return int  The current error level.
     */
    public function getErrorLevel()
    {
        return $this->errorLevel;
    }


    /**
     * Adds a new error to the error log. This should normally only be called by triggerError(), but is left protected if a class wishes to use it.
     *
     * @param string    $errorMessage   Text of message to log.
     *
     * @return void
     */
    protected function newError($errorMessage)
    {
        $this->errors[] = $errorMessage;
    }


    /**
     * Returns the last logged error.
     *
     * @return string  The last logged error.
     */
    public function getLastError()
    {
        return end($this->errors);
    }


    /**
     * Clears the error log.
     *
     * @return void
     */
    public function clearErrors()
    {
        $this->errors = array();
    }

    /*********************************************************
     ************************* END ***************************
     ******************** Error Handling *********************
     *********************************************************/


    /*********************************************************
     ************************ START **************************
     ********************* Transactions **********************
     *********************************************************/


    /**
     * Begin a transaction. When an error is encountered, {@link database::rollbackTransaction} will be invoked automatically.
     * Depending on the implementation, these may or may not be nestable.
     *
     * @return void
     */
    abstract function startTransaction();


    /**
     * Manually rollback a transaction. This is called automatically when an error is encountered.
     *
     * @return void
     */
    abstract function rollbackTransaction();


    /**
     * End a transaction.
     *
     * @return void
     */
    abstract function endTransaction();



    /*********************************************************
     ************************* END ***************************
     ********************* Transactions **********************
     *********************************************************/


    /*********************************************************
     ************************ START **************************
     ****************** Database Functions *******************
     *********************************************************/

    /**
     * Creates a new database on the database server. This function is not possible on all drivers (e.g. PostGreSQL).
     *
     * @param string  $database   The name of the databse.
     *
     * @return bool     True if the operation was successful, false otherwise.
     */
    abstract public function createDatabase($database);


    /**
     * Alters the active database of the connection. This function is not possible on all drivers (e.g. PostGreSQL). The connection character set will also be set to UTF-8 on certain drivers (e.g. MySQL).
     *
     * @param string    $database   The name of the databese.
     *
     * @return bool     True if the operation was successful, false otherwise.
     */
    abstract public function selectDatabase($database);

    /*********************************************************
     ************************* END ***************************
     ****************** Database Functions *******************
     *********************************************************/


    /*********************************************************
     ************************ START **************************
     ******************* Table Functions *********************
     *********************************************************/

    /**
     * Creates a table based on the specified data.
     *
     * In this example, a new table, named "table1" will be created using the primary store type and with three columns, one each for integers, strings, and bitfields.
     * ```php
     * $db = new database('localhost', 3306, 'root', 'r00tpassword', 'database1', 'mysqli');
     * $db->createTable('table1', 'Our first table!', 'general', array(
     *   'column1' => array(
     *     'type' => 'int',
     *     'maxlen' => 10,
     *     'autoincrement' => true,
     *   ),
     *   'column2' => array(
     *     'type' => 'string',
     *     'maxlen' => 10,
     *     'restrict' => array('value1', 'value2', 'value3'),
     *   ),
     *   'column3' => array(
     *     'type' => 'bitfield',
     *     'bits' => 8,
     *   ),
     * ), array(
     *   'column1' => array(
     *     'type' => 'primary'
     *   ),
     *   'column2,column3' => array(
     *     'type' => 'unique',
     *   ),
     * ));
     * ```
     *
     * Implementor Notes:
     *  - Implementers do not need to support $tableComment, which is only used for when developers wish to interact with the database. It serves no real purpose aside from documentation.
     *  - Implementers are required to populate $this->storeTypes as described in its documentation.
     *  - Implementers are required to support autoincrement on integer columns. If native support does not exist, this should be simulated, for instance by including a column property known as "uniqueValue" that increments with each insert, by maintaining a cache or database schema, or, if a database can function smoothly in doing so, by selecting the last inserted row in a table. For instance, in a JSON implementation, one could support a table as { row 1 : {} row 2 : {} uniqueValue : INT }.
     *  - Restrict is strongly encouraged for implementation, but strictly speaking is not required. Developers of applications using the database are encouraged to validate data prior to database insertion. Implementations that do not support "restrict" should note this, so that developers can accomodate. (FreezeMessenger does validate all input, but also includes "restrict" for documentation purposes.)
     *  - Finally, indexes are designed around SQL concepts. Implementators can support "primary" and "index" indexes mostly at their descretion -- they shouldn't affect a query's logic flow, and only exist to increase the speed of queries (something some implementations may benefit from, but others may not). However, "unique", which species that an index can not be duplicatd, must be emulated if it is not natively supported. Schema is the recommended way to emulate this: when the implementation's __construct is called, it should retrieve all unique indexes (likely from a cache or schema table). All insert() calls should then check to see if a unique index is violated, and respond accordingly.
     *
     * @param string    $tableName      The name of the table.
     * @param string    $tableComment   A table comment, used for documentation and related purposes.
     * @param string    $storeType      The class of database engine to use for the table, either "memory" or "general". The "memory" type should be used for tables that contain cache data, or otherwise where the table could be emptied without issue.
     * @param array     $tableColumns   The columns of the table as an array in which all entries should be <code>array(columnName => columnProperties)</code>. The following is a list of allowed indexes for any given "type" index:
     *  - "int" type: INT "maxlen", BOOL "autoincrement"
     *  - "string" type: INT "maxlen", ARRAY "restrict"
     *  - "bitfield" type: INT "bits"
     *  - "time" type: none
     *  - "bool" type: none
     * @param array     $tableIndexes    The indexes of the table.
     *
     * @return bool     True on success, false on failure.
     */
    abstract public function createTable($tableName, $tableComment, $storeType, $tableColumns, $tableIndexes);


    /**
     * Renames/moves a table. It will remain in the active database.
     *
     * In this example, the table named "table1" will be renamed to "specialTable1":
     * ```php
     * $db = new database('localhost', 3306, 'root', 'r00tpassword', 'database1', 'mysqli');
     * $db->renameTable('table1', 'specialTable1');
     * ```
     *
     * @param string    $oldName    The current table name.
     * @param string    $newName    The name the table should be renamed to.
     *
     * @return bool     True on success, false on failure.
     */
    abstract public function renameTable($oldName, $newName);


    /**
     * Alter's a table's comment or engine.
     *
     * In this example, the table named "table1" will become a memory table with the comment "Whee! Memory table!"
     * ```php
     * $db->alterTable('table1', 'Whee! Memory table!', 'memory');
     * ```
     *
     * @param string    $tableName      The table to alter.
     * @param string    $tableComment   A new comment for the table; specify null to not update.
     * @param string    $storeType      A new store type for the table; specify null to not update.
     *
     * @return bool     True on success, false on failure.
     */
    abstract public function alterTable($tableName, $tableComment, $storeType, $partitionColumn);


    /**
     * Adds new columns to an existing table.
     *
     * In this example, the table named "table1" will have two new columns, newcolumn1 and newcolumn2, added, matching their given definitions.
     * ```php
     * $db->createTableColumns('table1', [
     *   'newcolumn1' => [
     *     'type' => 'int', 'maxlen' => 10, 'autoincrement' => true,
     *   ],
     *   'newcolumn2' => [
     *     'type' => 'string', 'maxlen' => 10, 'restrict' => array('value1', 'value2', 'value3'),
     *   ],
     * ]);
     * ```
     *
     * @param string    $tableName     The table to to add columns to.
     * @param string    $tableColumns  An array of new columns to create, of the same format as {@link database::createTable()}
     *
     * @return bool     True on success, false on failure.
     */
    abstract public function createTableColumns($tableName, $tableColumns);


    /**
     * Updates a table's existing columns to new typing.
     *
     * In this example, the table named "table1" will two of its existing columns, column1 and column2, updated to their definition.
     * ```php
     * $db->alterTableColumns('table1', [
     *   'column1' => [
     *     'type' => 'int', 'maxlen' => 10, 'autoincrement' => true,
     *   ],
     *   'column2' => [
     *     'type' => 'string', 'maxlen' => 10, 'restrict' => array('value1', 'value2', 'value3'),
     *   ],
     * ]);
     * ```
     *
     * @param string    $tableName     The table whose columns will be modified.
     * @param string    $tableColumns  An array of new columns to create, of the same format as {@link database::createTable()}
     *
     * @return bool     True on success, false on failure.
     */
    abstract public function alterTableColumns($tableName, $tableColumns);


    /**
     * Deletes a table.
     *
     * In this example, the table named "table1" will be deleted:
     * ```php
     * $db = new database('localhost', 3306, 'root', 'r00tpassword', 'database1', 'mysqli');
     * $db->deleteTable('table1');
     * ```
     *
     * @param string    $tableName      The table to delete.
     *
     * @return bool     True on success, false on failure.
     */
    abstract public function deleteTable($tableName);


    /**
     * Returns an array of the tables in a database. The method used is driver specific, but where possible the SQL-standard INFORMATION_SCHEMA database will be used.
     *
     * @return array    All table names (as strings) in a database.
     */
    abstract public function getTablesAsArray();

    /*********************************************************
     ************************* END ***************************
     ******************* Table Functions *********************
     *********************************************************/


    /*********************************************************
     ************************ START **************************
     ******************** Row Functions **********************
     *********************************************************/


    /**
     * Set a where condition to be used in the next applicable query (one of select, delete, or update).
     *
     * For example, these two calls are equivalent:
     * ```php
     * // Method 1
     * $db->select(['tableName' => 'col1, col2'], ['col1' => $db->col('col2')]);
     *
     * // Method 2
     * $db->where(['col1' => $db->col('col2')])->select(['tableName' => 'col1, col2'])
     * ```
     *
     * Wheres cannot be chained; that is, $db->where(condition1)->where(condition2) will only apply condition2. However, where, sortBy, and limit can all be chained.
     *
     * @param array $conditionArray The where condition array. See {@link database::select()} for additional information. (TODO: document here, link from elsewhere)
     *
     * @return $this
     */
    public function where($conditionArray)
    {
        $this->conditionArray = $conditionArray;

        return $this;
    }


    /**
     * Set a sort order to be used in the next applicable query (a select).
     *
     * For example, these two calls are equivalent:
     * ```php
     * // Method 1
     * $db->select(['tableName' => 'col1, col2'], ['col1' => $db->col('col2')], ['col1' => 'asc']);
     *
     * // Method 2
     * $db->where(['col1' => $db->col('col2')])->sortBy(['col1' => 'asc'])->select(['tableName' => 'col1, col2'])
     * ```
     *
     * @param array $sortArray The sort order array. See {@link database::select()} for additional information. (TODO: document here, link from elsewhere)
     *
     * @return $this
     */
    public function sortBy($sortArray)
    {
        $this->sortArray = $sortArray;

        return $this;
    }


    /**
     * Set a sort order to be used in the next applicable query (a select).
     *
     * For example, these two calls are equivalent:
     * ```php
     * // Method 1
     * $db->select(['tableName' => 'col1, col2'], ['col1' => $db->col('col2')], ['col1' => 'asc']);
     *
     * // Method 2
     * $db->where(['col1' => $db->col('col2')])->sortBy(['col1' => 'asc'])->select(['tableName' => 'col1, col2'])
     * ```
     *
     * @param array $sortArray The sort order array. See {@link database::select()} for additional information. (TODO: document here, link from elsewhere)
     *
     * @return $this
     */
    public function limit($limitArray)
    {
        $this->limitArray = $limitArray;

        return $this;
    }


    /**
     * Gives contextual information for hard partitioning.
     *
     * For instance, let's say "table1" is partitioned by the "id" column. It has 10 tables for this -- table1_0, table1_1, table1_2, and so-on, where the suffix is a hash of the id column, id%10.
     * Let's say we now want to update only one specific table. We can use partitionAt to specify an example ID column to calculate the hash for -- all rows with a matching ID, or any ID with the same hash, will be updated.
     * ```php
     * // Delete all rows in the partitioned table only that are older than 10 minutes.
     * $db->partitionAt(['id' => 1])->delete(['time' => $this->now(-600)]);
     * ```
     *
     * @param array $conditionArray Information to be used for calculating a partiton table.
     *
     * @return $this
     */
    public function partitionAt($conditionArray)
    {
        $this->partitionAt = $conditionArray;

        return $this;
    }



    /**
     * Retrieves data from the active database connection.
     *
     * @param array     $columns    The columns to select. Must be an associative array where the key is the table name and the value is columns. Values can be:
     *  - A comma-separated list: ['tableName1' => 'tableColumn1, tableColumn2', ...]
     *  - An array: ['tableName1' => ['tableColumn1', 'tableColumn2'], ...]
     * Column names can be followed by a space and a second name, which will be treated as an alias:
     *  - A comma-separated list: ['tableName1' => 'tableColumn1 tableColumn1Alias, tableColumn2', ...]
     *  - An array: ['tableName1' => ['tableColumn1 tableColumn1Alias', 'tableColumn2'], ...]
     * If an alias is provided, it must be used in the condition, sort, and limit arrays. No column name may be repeated; if two columns with the same names are being selected, use an alias on at least one.
     *
     * @param array     $conditionArray     The conditions for the selection. The basic format is as such:
     *   - ['lvalueColumn' => 'rvalue']: A simple comparison, where the column named "lvalue" must equal the string "rvalue"
     *   - ['lvalueColumn' => $db->type('string', 'rvalue')]: Use {@link database::type()} to explicitly specify the rvalue type. This is required for, e.g., columns.
     *   - ['lvalueColumn' => $db->type('int', 10, 'gt')]: Use {@link database::type()} to specify non-equality conditions, as well.
     *   - ['lvalueColumn' => $db->int(10, 'gt')]: Several shorthand functions exist.
     *   - ['lvalueColumn' => $db->str('rvalue')]: Several shorthand functions exist.
     *   - ['both' => ['lvalueColumn' => $db->str('rvalue')]], ['lvalueColumn2' => $db->int(10)]]]: Conditions can be chained by replacing the lvalue with either "both" or "either", which represent AND and OR combinations
     *
     * @param array|string  $sort   A string or array defining how to sort the return data.
     * @param int           $limit  The maximum number of columns to select.
     *
     * @return object
     */
    abstract public function select($columns, $conditionArray = false, $sort = false, $limit = false);


    /**
     * Inserts a row into a table of the database.
     *
     * In this example, a row will be inserted with values specified for column1, column2, and column4.
     * ```php
     * $db = new database('localhost', 3306, 'root', 'r00tpassword', 'database1', 'mysqli');
     * $db->insert('table1', array(
     *   'column1' => 'value1',
     *   'column2' => 'value2',
     *   'column4' => 'value4',
     * ));
     * ```
     *
     * Implementor Notee:
     *  - The UPDATE functionality is required of all implementations. This could be implemented using a single query, as with most SQL variations, but it could also first check to see if a key restriction exists, and then either inserting or updating accordingly. If a database does not have native key restrictions, implementators are encouraged to support "simulated" key restrictions as defined in createTable().
     *
     * @param string $table         The table to insert into.
     * @param array  $dataArray     The data to insert into the database.
     * @param array  $updateArray   If the row can not be inserted due to key restrictions, this defines data to update the row with instead (see MySQL's ON DUPLICATE KEY UPDATE).
     *
     * @return bool - True on success, false on failure.
     */
    abstract public function insert($table, $dataArray);


    /**
     * Inserts a row into a table of the database.
     *
     * In this example, an existing row's values will be updated as shown whereever both that rows' "column2" is equal to "value2" and that rows' "column3" is equal to "column3".
     * ```php
     * $db = new database('localhost', 3306, 'root', 'r00tpassword', 'database1', 'mysqli');
     * $db->update('table1', array(
     *   'column1' => 'value1',
     *   'column2' => 'value4',
     *   'column4' => 'value4',
     * ), array(
     *   'column2' => 'value2',
     *   'column3' => 'value3',
     * ));
     * ```
     *
     * @param string $table             The table to update.
     * @param array  $dataArray         The data to update the row(s) with.
     * @param array  $conditionArray    The conditions to apply to the UPDATE.
     *
     * @return bool     True on success, false on failure.
     */
    abstract public function update($table, $dataArray, $conditionArray = false);



    /**
     * Inserts a row into a table, updating an existing row if a key conflict exists.
     * If a row matching $conditionArray already exists, it will be updated to reflect $dataArray. If it does not exist, a row will be inserted that is a composite of $conditionArray, $dataArray, and $dataArrayOnInsert.
     * On systems that support OnDuplicateKey, this will NOT test the existence of $conditionArray, relying instead on the table's keys to do so. Thus, this function's $conditionArray should always match the table's own keys. Otherwise, the behaviour of this function will vary by driver.
     *
     * In this example, a row will be inserted with values specified for column1, column2, and column4. If a row with the same value for column1 already exists, however (as determined by a SELECT query or built-in on-duplicate-key check in supported drivers), then the existing row will have only column2 updated instead.
     * ```php
     * $db = new database('localhost', 3306, 'root', 'r00tpassword', 'database1', 'mysqli');
     * $db->insert('table1', array(
     *   'column1' => 'value1',
     * ), array(
     *   'column1' => 'value1',
     *   'column2' => 'value2',
     * ), array(
     *   'column4' => 'value4',
     * ));
     * ```
     *
     * @param string $tableName                 The table to upsert into.
     * @param array  $conditionArray        The conditions of the update. This does not support database type objects (those returned by the type() function) or combiners; that is, it can only be a one-level associative array of column-value pairs.
     * @param array  $dataArray             The data to update. This must be an associative array of column-value pairs.
     * @param array  $dataArrayOnInsert     Extra data to add only on insert. This must be an associative array of column-value pairs.
     *
     * @return bool     True on success, false on failure.
     */
    public function upsert($tableName, $conditionArray, $dataArray, $dataArrayOnInsert = [])
    {
        switch ($this->language) {
        case 'mysql':
            $allArray = array_merge($dataArray, $dataArrayOnInsert, $conditionArray);
            $allColumns = array_keys($allArray);
            $allValues = array_values($allArray);

            $query = 'INSERT INTO ' . $this->formatValue('table', $tableName) . '
        ' . $this->formatValue('tableColumnValues', $tableName, $allColumns, $allValues) . '
        ON DUPLICATE KEY UPDATE ' . $this->formatValue('tableUpdateArray', $tableName, $dataArray);

            if ($queryData = $this->rawQuery($query)) {
                $this->insertIdCallback($tableName, $this->functionMap('insertId'));

                return $queryData;
            }
            else return false;
        break;
        }
    }


    /**
     * Deletes rows from a table of the database.
     *
     * In this example, one or more existing rows will be deleted whereever both that rows' "column2" is equal to "value2" and that rows' "column3" is equal to "column3":
     * ```php
     * $db = new database('localhost', 3306, 'root', 'r00tpassword', 'database1', 'mysqli');
     * $db->delete('table1', array(
     *   'column2' => 'value2',
     *   'column3' => 'value3',
     * ));
     * ```
     *
     * @param string $table         The table to delete from.
     * @param array  $updateArray   The conditions to delete rows by, same as in {@link database::select()}
     *
     * @return bool     True on success, false on failure.
     */
    abstract public function delete($table, $conditionArray = false);

    /*********************************************************
     ************************* END ***************************
     ******************** Row Functions **********************
     *********************************************************/




    /*********************************************************
     ************************ START **************************
     ******************** Queue Functions ********************
     *********************************************************/

    /**
     * Enable or disable autoQueue.
     * When autoQueue is turned on, all insert(), update(), and delete() calls are automatically put into the queue.
     * When autoQueue is turned off, the queue is processed.
     *
     * @param bool $on True to turn on, false to turn off.
     * @return void
     */
    abstract public function autoQueue(bool $on);


    /**
     * Queue an update, but don't perform it until processQueue is called.
     * This function can be used to allow optimisations.
     *
     * @param array $tableName      See {@link database::update()}.
     * @param array $dataArray      See {@link database::update()}.
     * @param array $conditionArray See {@link database::update()}.
     */
    abstract public function queueUpdate($tableName, $dataArray, $conditionArray = false);


    /**
     * Queue a deletion, but don't perform it until processQueue is called.
     * This function can be used to allow optimisations.
     *
     * @param array $tableName  See {@link database::delete()}.
     * @param array $dataArray  See {@link database::delete()}.
     */
    abstract public function queueDelete($tableName, $dataArray);


    /**
     * Queue an insert, but don't perform it until processQueue is called.
     * This function can be used to allow optimisations.
     *
     * @param $tableName    See {@link database::insert()}.
     * @param $dataArray    See {@link database::insert()}.
     */
    abstract public function queueInsert($tableName, $dataArray);


    /**
     * Runs all queued operations in sequence, combining and optimisation queries if possible.
     */
    abstract public function processQueue();

    /*********************************************************
     ************************* END ***************************
     ******************** Queue Functions ********************
     *********************************************************/




    /*********************************************************
     ************************ START **************************
     **************** Type-Casting Functions *****************
     *********************************************************/


    protected function isTypeObject($type)
    {
        return (is_object($type) && get_class($type) === 'DatabaseType'); // TODO: instanceof, dummy
    }

    /**
     * Define a value as being of a certain type for database operations.
     *
     * @param mixed  $value  The value to "type".
     * @param string $type   The type to attribute to the value, either:
     *  - 'int', an integer
     *  - 'ts', a timestamp
     *  - 'str', a string
     *  - 'col', a column
     *  - 'float', a floating point
     *  - 'bool', a bool
     *  - 'equation', an equation, which allows for very limited column equation comparisons (e.g. "$colName + 1")
     *  - 'blob', a binary blob, signifying a string that must not have any character encoding applied.
     *  - 'array', an array of values, primarily intended for IN queries
     * @param mixed $comp   How the value will be compared to the data present as an index, either:
     *  - 'search', where rvalue is a substring of lvalue
     *  - 'e', for equality
     * - 'lt', 'lte', 'gt', 'gte', for less/greater than and/or equals
     * - 'in', 'notin' - For lvalue to be in (or not in) an rvalue array.
     * - 'bAnd' - Rvalue is a binary bit subset of lvalue.
     *
     * Internal Notes:
     *   - Note that minimal casting actually occurs here, and should instead be performed by the select() function in each implementation. Instead, it simply ensures that basic PHP typing is present: integer for integers and timestamps, strings for strings and columns, arrays for arrays, and floats for floats.
     *   - The type and equality operations will always maintain their shorter string equivilents, as it makes it easier to write the code, but using the DatabaseTypeComparison and DatabaseTypeType operations is still recommended.
     *
     * @return DatabaseType A special representation of a column int only for use in database functions.
     */
    public function type($type, $value = '', $comp = 'e')
    {
        switch ($comp) {
            case 'e':      $typeComp = DatabaseTypeComparison::equals;            break;
            case 'lt':     $typeComp = DatabaseTypeComparison::lessThan;          break;
            case 'lte':    $typeComp = DatabaseTypeComparison::lessThanEquals;    break;
            case 'gt':     $typeComp = DatabaseTypeComparison::greaterThan;       break;
            case 'gte':    $typeComp = DatabaseTypeComparison::greaterThanEquals; break;
            case 'search': $typeComp = DatabaseTypeComparison::search;            break;
            case 'in':     $typeComp = DatabaseTypeComparison::in;                break;
            case 'notin':  $typeComp = DatabaseTypeComparison::notin;             break;
            case 'bAnd':   $typeComp = DatabaseTypeComparison::binaryAnd;         break;

            default:
                throw new Exception("Invalid comparison '$comp'");
                break;
        }


        switch ($type) {
            case 'int': case 'integer': case DatabaseTypeType::integer:
                return new DatabaseType(DatabaseTypeType::integer, (int)$value, $typeComp);
                break;

            case 'ts': case 'timestamp': case DatabaseTypeType::timestamp:
                return new DatabaseType(DatabaseTypeType::timestamp, (int)$value, $typeComp);
                break;

            case 'str': case 'string': case DatabaseTypeType::string:
                return new DatabaseType(DatabaseTypeType::string, (string)$value, $typeComp);
                break;

            case 'col': case 'column': case DatabaseTypeType::column:
                return new DatabaseType(DatabaseTypeType::column, (string)$value, $typeComp);
                break;

            case 'float': case DatabaseTypeType::float:
                return new DatabaseType(DatabaseTypeType::float, (string)$value, $typeComp);
                break;

            case 'bool': case DatabaseTypeType::bool:
                return new DatabaseType(DatabaseTypeType::bool, (bool)$value, DatabaseTypeComparison::equals);
                break;

            case 'empty': case DatabaseTypeType::null:
                return new DatabaseType(DatabaseTypeType::null, DatabaseType::null, DatabaseTypeComparison::equals);
                break;

            case 'equation': case DatabaseTypeType::equation:
                return new DatabaseType(DatabaseTypeType::equation, (string)$value, $typeComp);
                break;

            case 'blob':case 'binary': case DatabaseTypeType::blob:
                return new DatabaseType(DatabaseTypeType::blob, $value, $typeComp);
                break;

            case 'arr': case 'array': case DatabaseTypeType::arraylist:
                if (count($value) === 0)
                    $this->triggerError('An empty array was specified.', false, 'validationFallback');

                return new DatabaseType(DatabaseTypeType::arraylist, (array)$value, $typeComp);
                break;

            default:
                $this->triggerError("Unrecognised type '$type'");
                break;
        }
    }

    /**
     * An in-array operation. Shorthand for type('arr', $value, 'in')
     *
     * @param $mixed value
     * @return DatabaseType
     */
    public function in($value)
    {
        return $this->type('arr', $value, 'in');
    }

    /**
     * A search (substring) operation. Shorthand for type('string', $value, 'search')
     *
     * @param mixed $value
     * @return DatabaseType
     */
    public function search($value)
    {
        return $this->type('string', $value, 'search');
    }

    /**
     * A boolean value. Shorthand for type('bool', $value)
     *
     * @param mixed $value
     * @return DatabaseType
     */
    public function bool($value)
    {
        return $this->type('bool', $value);
    }

    /**
     * A blob value. Shorthand for type('blob', $value)
     *
     * @param mixed $value
     * @return DatabaseType
     */
    public function blob($value)
    {
        return $this->type('blob', $value);
    }

    /**
     * An integer comparison. Shorthand for type('int', $value, $comp)
     *
     * @param mixed $value
     * @param string $comp
     * @return DatabaseType
     */
    public function int($value, $comp = 'e')
    {
        return $this->type('int', $value, $comp);
    }


    /**
     * A floating-point comparison. Shorthand for type('float', $value, $comp)
     *
     * @param mixed $value
     * @param string $comp
     * @return DatabaseType
     */
    public function float($value, $comp = 'e')
    {
        return $this->type('float', $value, $comp);
    }


    /**
     * A timestamp comparison. Shorthand for type('ts', $value, $comp)
     *
     * @param mixed $value
     * @param string $comp
     * @return DatabaseType
     */
    public function ts($value, $comp = 'e')
    {
        return $this->type('ts', $value, $comp);
    }


    /**
     * A timestamp comparison using the current time plus an offset as the base. Shorthand for type('ts', time() + $offset, $comp)
     *
     * @param mixed $offset If positive, this many seconds in the future. If negative, this many seconds in the past.
     * @param string $comp
     * @return DatabaseType
     */
    public function now($offset = 0, $comp = 'e')
    {
        return $this->ts(time() + $offset, $comp);
    }


    /**
     * A string comparison. Shorthand for type('str', $value, $comp)
     *
     * @param mixed $value
     * @param string $comp
     * @return DatabaseType
     */
    public function str($value, $comp = 'e')
    {
        return $this->type('str', (string)$value, $comp);
    }


    /**
     * A column comparison. Shorthand for type('col', $value, $comp)
     *
     * @param mixed $value
     * @param string $comp
     * @return DatabaseType
     */
    public function col($value, $comp = 'e')
    {
        return $this->type('col', $value, $comp);
    }


    /**
     * An equation comparison. Shorthand for type('equation', $value, $comp)
     *
     * @param mixed $value
     * @param string $comp
     * @return DatabaseType
     */
    public function equation($value) {
        return $this->type('equation', $value);
    }

    /*********************************************************
     ************************* END ***************************
     **************** Type-Casting Functions *****************
     *********************************************************/

    /**
     * Applies $function to the $data. If $data is an instance of DatabaseType, its other values will be retained, though its type may change if $forceType is set to one of the DatabaseTypeType values.
     * If $data was not an instance of DatabaseType, it will be returned as one, with $forceType or DatabaseTypeType::string as its type, and DatabaseTypeComparison::equals as its comparison operator.
     *
     * @param callable $function
     * @param mixed|DatabaseType $data
     * @param bool|DatabaseTypeType $forceType
     * @return DatabaseType
     * @throws Exception
     */
    protected function applyTransformFunction($function, $data, $forceType = false): DatabaseType {
        // If $data is an instance of DatabaseType...
        if ($this->isTypeObject($data)) {
            // Equations and columns cannot be transformed.
            if ($data->type === DatabaseTypeType::equation || $data->type === DatabaseTypeType::column) {
                throw new Exception('Database data transformation attempted on unsuported object.');
            }

            // Lists are fancy -- we trasnsform the elements of the list recursively. The elements can be of any type that can be passed to applyTransformFunction normally.
            elseif ($data->type === DatabaseTypeType::arraylist) {
                foreach ($data->value AS &$value) {
                    $value = $this->applyTransformFunction($function, $value, $forceType);
                }

                return $data;
            }

            // All other values apply the function and, if $forceType is set, the relevant datatype. The comparison operator is not changed.
            else {
                return new DatabaseType(($forceType ? $forceType : $data->type), call_user_func($function, $data), $data->comparison);
            }
        }

        // If $data isn't an instance of DatabaseType, set it to one, with $forceType or DatabaseTypeType::string as its type, and DatabaseTypeComparison::equals as its comparison operator.
        else {
            return new DatabaseType(($forceType ? $forceType : DatabaseTypeType::string), call_user_func($function, $data), DatabaseTypeComparison::equals);
        }
    }


    /**
     * Opens a database result object using the specified parameters.
     *
     * @param object $queryData {@see databaseResult::$queryData}
     * @param string $reverseAlias {@see databaseResult::$reverseAlias}
     * @param string $sourceQuery {@see databaseResult::$sourceQuery}
     * @param database $database {@see databaseResult::$database}
     * @param bool $paginated {@see databaseResult::$paginated}
     *
     * @return databaseResult
     * @author Joseph Todd Parsons <josephtparsons@gmail.com>
     */
    abstract protected function databaseResultPipe($queryData, $reverseAlias, string $sourceQuery, database $database, int $paginated = 0);
}

require('DatabaseResult.php');
require('DatabaseType.php');
require('DatabaseTypeType.php');
require('DatabaseTypeComparison.php');

?>